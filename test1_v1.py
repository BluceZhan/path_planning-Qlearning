# -*- codeing = utf-8 -*-
# @Time : 2020/3/31 16:28
# @Author : liuyi
# @File : test1_v1.py
# @Software : PyCharm
# 参考英文论文,初始R是-1是不通，1是可以通过
import numpy as np
import random
np.set_printoptions(threshold=1e6)  # 设置打印数量的阈值
r = np.array([[-1,-0,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
              [-0,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
              [-1,-0,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
              [-1,-1,-1,-1,-0,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
              [-1,-1,-1,-0,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
              [-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
              [-0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
              [-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
              [-1,-1,-0,-1,-1,-1,-1,-0,-1,-0,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
              [-1,-1,-1,-0,-1,-1,-1,-1,-0,-1,-0,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
              [-1,-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
              [-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
              [-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
              [-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-0,-1,-0,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
              [-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
              [-1,-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
              [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-0,-1,-0,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
              [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
              [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
              [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-0,-1,-0,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
              [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1,-1],
              [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1],
              [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-0,-1,-0,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1],
              [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1],
              [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1],
              [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1,-1],
              [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-0,-1,-0,-1,-1,-1,-1,-0,-1,-1,-1],
              [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-0,-1,-0,-1,-1,-1,-1,-0,-1,-1],
              [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1],
              [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-0],
              [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1],
              [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-0,-1,-1,-1],
              [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-0,-1,-1,-1,-1],
              [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-1,-1,-0,-1],
              [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-0],
              [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-0,-1,-1,-1,-1,-0,-1],
#               0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35

              ])

for i in range(36):
    for j in range(36):
        if r[i, j] == 0:
            r[i, j] = 1

q = np.zeros([36, 36], dtype=np.float32)

gamma = 0.8


# 后期再实现根据坐标计算r值 。根据这三个参数，修改R矩阵
# 拐弯有8种情况，直线只有4中，所以采取奖赏的方式
def Rt(s_pre, s, a):
    if s_pre + 1 == s and s + 1 == a:  # 向右走了直线
        # r[s, a] += 0.4
        pass
    if s_pre - 1 == s and s - 1 == a:  # 向左走了直线
        # r[s, a] += 0.4
        pass
    if s_pre + 6 == s and s + 6 == a:  # 向下走了直线
        # r[s, a] += 0.4
        pass
    if s_pre - 6 == s and s - 6 == a:  # 向上走了直线
        # r[s, a] += 0.4
        pass
    else:
        r[s, a] -= 0.005


# 选择距离s最近的有值的状态,边缘不搜，一圈一圈的搜
def choose(s):
    x = 0
    for n in range(1,10):  # 判断方法：1、s周围不出界，2、s不是边缘，3、选择的这一步有值
        if s - n*1 >= 0 and s % 6 != 0 and r[s - n*1]:
            x = s - n*1
            break
        if s + n*1 <= 35 and (s+1) % 6 != 0 and r[s + n*1]:
            x = s + n*1
            break
        if s - n*6 >= 0 and s % 6 != 0 and r[s - n*6]:
            x = s - n*6
            break
        if s + n*6 <= 35 and (s+1) % 6 != 0 and r[s + n*6]:
            x = s + n*6
            break
        if n == 9:  # 保护机制：遍历寻找下一状态
            for ss in range(36):
                if not q1[new_state].any():
                    continue
                x = ss
            print("fail to choose next state, using search strategy ")
    return x


for step in range(1000):  # 先更新R，再更新Q
    #  state = random.randint(0, 35)
    state = 0  # 针对性的训练
    state_pre = 0  # 初始化前一个状态
    for i in range(44):  # 44条边, 后期实现根据图得到边的个数

        if r[state].any():  # 如果r[state]不空
            next_state_list = []
            for i in range(36):  # 当前state下的所有动作，收集到next_state_list
                if r[state, i] != -1:
                    next_state_list.append(i)
            next_state = next_state_list[random.randint(0, len(next_state_list) - 1)]

            Rt(state_pre, state, next_state)

            q[state, next_state] = r[state, next_state] + gamma * max(q[next_state])  # 注意qval是一个数值

            state_pre = state
            state = next_state

        else:
            next_state = choose(state)

            r[state,next_state] += -0.001

            q[state, next_state] = r[state, next_state] + gamma * max(q[next_state])  # 注意qval是一个数值

            state_pre = state
            state = next_state

print(q)
value = []
for i in range(36):
    for j in range(36):
        if q[i,j] != 0:
            value.append(q[i,j])
print(value)

# 、、、、、、、、、、、、、、、、、、、、、、、生成路径


state = 0  # 初始状态
print("robot start at {}".format(state))
q1 = q  # q1去循环变成0矩阵
while q1.any():  # 当q1不空
#for step in range(44):
    if not q1[state].any():  # 如果这一行全是0,就遍历找一个不全是0的state,肯定能找到
        for new_state in range(36):
            if not q1[new_state].any():
                continue
            print("from {} jump to {}".format(state, new_state))
            state = new_state
            break

    q_max = q1[state].max()  # 状态state这一行里的最大值，即回报最大的动作的回报值
    q_max_action = []

    for action in range(36):  # 找回报最大的动作
        if q1[state, action] == q_max:
            q_max_action.append(action)

    next_state = q_max_action[random.randint(0, len(q_max_action) - 1)]
    q1[state,next_state] = 0
    q1[next_state,state] = 0
    print("the robot goes to " + str(next_state) + '.')
    state = next_state
